# Ecosystem Analytics

## Motivation
A popularized form of software reuse is the use of distributable packages. Packages are modular
libraries packaged with reusable and extensible functionality. As an example, a software project in
need of parsing JSON files can use a parsing package instead of developing and maintaining this
functionality by themselves. Furthermore, developers can also build new packages on top of existing
packages. As an example, a developer building a general-purpose parser for the web can depend and
build upon the JSON parser package. 

To make packages available in software projects, package managers provide an automized workflow to
fetch remote packages, resolve compatibility constraints between them and then integrate them into
projects. Package managers can also be seen as "batteries included" for programming languages. For
example, pip[^5.1] and Cargo[^5.2], official package managers for Python and Rust, provide its
users with vast community developed and tested packages. The use of package managers is also
immensely popular; npm, the de-facto package manager for JavaScript, recorded 18 billion package
downloads in one month @Linux2016.

Additionally, there is also an increasing trend towards creating open source projects. In the time
span of one week, npm register 4,685 newly created packages @Linux2016. An enabling factor of this
trend is social coding platforms such as GitHub[^5.3], that provides an open environment for
package communities to develop, review and use newly developed projects. Thus, leading to early
adaption and widespread within package communities.

As a consequence, software projects that import functionality from remotely-developed packages, and
also at the same time export functionality as a package for others are increasingly becoming
interdependent. In a shared environment such as npm or Github, the interdependence between software
projects form a global graph-like structure known as a _software ecosystem_, where nodes represent
software projects and edges represent the dependency between them. 

As the interdependence between software projects in a shared environment encompasses more than the
code that they depend on; several attempts have been made to define the phenomena around software
ecosystems: Messerschmitt and Szyperski @Messerschmitt2003 state that a software ecosystem is
"a collection of software products that have some given degree of symbiotic relationships". On a
similar line, Lungu @Lungu2009 defines a context to the symbiotic relationship between projects: "A
software ecosystem is a collection of software projects which are developed and co-evolve in the
same environment." An overlooked element is the social-technical relationships between dependent
projects, Mens et al. @Mens2013 incorporate this aspect to Lungu's @Lungu2009 definition with the
following extension: "by explicitly considering the communities involved (e.g. user and developer
communities) as being part of the software ecosystem". Stallman @Stallman2002 opposes the use of
software ecosystem to describe interdependent networks of software projects: "It is inadvisable
to describe the free software community, or any human community, as an ecosystem, because that word
implies the absence of ethical judgment." Although software ecosystems are subject to ethical
judgments, this is not a limiting factor to capture interconnected software projects as an
ecosystem. 

This chapter will use Mens et al.'s @Mens2013 definition of software ecosystems as it is the most
modern and comprehensive definition (i.e., also including the social interaction) to describe and
study interconnected software projects.

Software ecosystems are interesting from two analytics perspectives, one being the _landscape
perspective_ of contemporary software problems and the other being the _network perspepective_ for
studying the propagation of contemporary software problems. Together they make up _ecosystem
analytics_. The two perspectives can yield meaningful insights to identify the spread of common
inefficiencies in software development processes or critical deficiency in source code. As an
example, the network perspective of software ecosystems provides effective means to identify
projects affected by a vulnerability originating from a distant software project. 

Through the lens of a literature survey, this chapter reviews and consolidates recent research of
ecosystem analytics from both a theoretical and practical standpoint. By synthesizing recent
studies, practices, open challenges and applications of ecosystem analytics, we aim to equip the
reader with a comprehensive overview and recommendations for future research in this field. Thus,
we have formulate the following three research questions:

* **RQ1**: What is the current state of the art in software analytics for ecosystem analytics?
* **RQ2**: What are the practical implications of the state of the art?
* **RQ3**: What are the open challenges in ecosystem analytics, for which future research is
  required?

Each of these research questions will be answered using recent papers written in this field of
research. This chapter is structured as follows: First, the research protocol is described in
detail. This includes decisions on which papers are included in the review. After this, the
research questions are answered using the previously stated set of papers.

## Research Protocol

In order to review literature to answer the research questions given in the previous section, the
survey method suggested by Kitchenham is used, conform to @kitchenham2004procedures.
This method creates a systematic
way to select a set of papers, which is relevant to the research question(s).

The search strategy, as described by Kitchenham @kitchenham2004procedures,
are usually iterative and benefit
from consultations with experts in the field, among other things. Our search strategy can be split
in three different types:

* the initial seed, given by an expert in the field, MSc. Joseph Hejderup
* a search using a digital search engine, namely Google Scholar[^5.4]
* a selection of referenced papers within papers selected before in the above two searches

### Initial seed
MSc. Joseph Hejderup has provided us with a total of thirteen papers, as shown in Table 4.1.

As each of these papers come from an expert in the field, each paper is assumed to be relevant to
at least the field of software ecosystems. Because of this, each of these papers were judged on
their relevance to either of the research questions. In Table 4.1, this relevance judgment is
shown in the left column, since a paper is only selected, if the paper is indeed relevant. Table
4.2 describes the reason for which each particular paper is not selected for the literature
survey.

### Digital Search Engine
The second strategy type which is used to select relevant papers for this literature study, is by
a digital search engine. In this literature survey, Google Scholar[^5.4] is used. From the initial
seed, common keywords were retrieved and the following queries have been used to search for
relevant papers:

* "engineering software ecosystems" _(2014)_
* "software ecosystems" AND "empirical analysis" _(2018)_
* "software ecosystem" AND "empirical" _(2014)_
* "software ecosystem analytics" _(2014)_
* "software ecosystem" AND "analysis" _(2017)_

For each of these queries, the results were first filtered by the publish year. These are
described by the italic year after each query above. The papers that are filtered are published
earlier than the set publish year. These specific years were chosen since the survey focuses on
the state of the art within the ecosystem analytics. The difference in years per query is a result
from not finding relevant papers in more recent times (e.g. for "software ecosystem analytics",
the year is _2014_ because setting the filter to _2018_ or _2017_ did not result in relevant
papers).

After this filtering, we first determined whether a paper was relevant to the literature survey by
examining the title. If it was unclear whether the paper was indeed relevant by only looking at
the title, the abstract of the paper was examined closely. On these two criteria, each of the
selected papers were judged and ultimately selected. The selected paper using these method can be
found in Table 4.3.

### Referenced papers
The third method we use is by looking at the references found in the selected papers, using the
two methods above. A selection has been made from these references. For these papers, the
selection process is similar to that of the selected papers using the digital search engine; it is
selected when both the title and the abstract are deemed relevant to the research questions. This
has led to the papers in Table 4.4. being selected.

## Answers
In this section, an aggregation of information, found in the papers, is presented. Each subsection
of this section focuses on one of the three research questions posed in Section 1.

### RQ1: What is the current state of the art in software analytics for ecosystem analytics?
<!-- Topics that are being explored, research methods, tools and datasets being used -->
To answer this research question, we examine the explored topics in ecosystem analytics. Moreover,
we summarize which research methods, tools and datasets are being used to explore this topics.

#### Explored Topics
The main topics we explored in ecosystem analytics are the usage of trivial packages, (breaking)
changes in dependencies and their impacts, quality of dependencies and dependency networks.

Trivial packages are a recurring topic in the area of software analytics, notably incidents
like Left-pad, Schleuter @NPM2016, stress the possible impact trivial packages can have on a software ecosystem.
Research in this topic explores the usage of trivial packages both quantitatively and qualitatively
by analysing the usage of the trivial packages and the reasons why developers choose to use them
respectively.

Breaking changes is a major topic researched by some papers. Much like trivial packages research
is done both quantitatively and qualitatively in this topic. The impact of breaking changes and the
way in which developers react to these changes are considered to be the notable problems in 
this topic.

Establishing a metric for the health of an ecosystem dependency is also a heavily explored topic.
Researchers are trying to find ways in which a metric can be used to establish the quality of
dependencies.

Dependency networks allow us to gain insight in the way in which ecosystems evolve over time.

#### Used Research Methods
The studied papers cover a plethora of research methods. These methods can be divided into two
categories: quantitative and qualitative.

Many quantitative research papers analyse the data in a statistical manner, using software
ecosystems as their data. The types of data depend heavily on the ecosystem used for analysis.
Some papers go as far as using the source code of packages @Abdalkareem2017. While other
research focusses on the meta-data of software ecosystems, such as dependency networks @Kikas2017.
Another recurring research method is survival analysis, as used by @Decan2018, which can be used
to estimate the survival rate of a population over time. In software engineering this has
been successfully applied to open source projects.

Some qualitative research has been done in software ecosystems to gain a better understanding
in to the behaviour of the interactions between developers and software ecosystems. Some
papers solely rely on the results of qualitative research whereas some papers use both quantitative
research and qualitative research to triangulate their findings.

#### Used Ecosystems
As has been said above, the most common explored topic within the body of studied papers are
topics relating to dependencies between different software projects. Therefore, it does make a lot
of sense that the most common ecosystems used are those of package managers, since these package
managers are central repositories from which the packages, as well as their dependencies, can
easily be retrieved.

The most common used ecosystem in the studied papers is _npm_[^5.5], as used by Abdalkareem et al.
@Abdalkareem2017, Bogart et al. @Bogart2016, Decan, Mens, and Claes @Decan2017, Kikas et al.
@Kikas2017, and Decan, Mens and Grosjean @Decan2018. There are a few reasons why this is the most
common used ecosystem throughout the papers. Firstly, npm is the largest software registry,
containing more than double of the next most populated package registry in 2016 @Linux2016.
Moreover, npm is the package manager of JavaScript, which is the
most used programming language according to a RedMonk survey @RedMonk2018. Kikas et al.
@Kikas2017 explain that it is beneficial to use this ecosystem, because the majority of their
packages are hosted on GitHub and Developers specify required packages in their project's
dependency files. There are more ecosystems which have the same properties, such as RubyGems
(Ruby) and Crates.io (Rust) @Kikas2017.

However, these are not the only used ecosystems. Decan, Mens, and Grosjean @Decan2018 use the
_libraries.io_ dataset for their research, which includes seven different packaging ecosystems:
Cargo (rust), CPAN (Perl), CRAN (R), npm (JavaScript), NuGet (.NET), Packagist (PHP) and RubyGems
(Ruby). Decan, Mens, and Grosjean @Decan2018 therefore study the most different ecosystems in one
paper, relative to the papers studied in this survey.

Apart from these datasets based on packages in package repositories, there are papers which use
other datasets and therefore ecosystems as well. Bavota et al. @Bavota2014 research the Apache
Community and therefore uses a dataset corresponding to the full Java subset of the Apache
ecosystem. Cox et al. @Cox2015 instead use the dataset of the Apache Maven Project to validate his
created metric. Claes et al. @Claes2015 research package incompatibilities and therefore uses a
ten year period of the Debian i386 testing and stable distributions. Robbes, Lungu, and
RÃ¶thlisberger @Robbes2012 opted for the Squeak/Pharo ecosystem, as they stated that this ecosystem
would provide support for answering their research questions.

#### Main research findings
Based on the findings of Abdalkareem et al. @Abdalkareem2017 trivial packages make up 16.8% of the
NPM packages. Even though 10% of NPM uses trivial packages only 45% of these trivial packages have
tests.

Robbes et al. @Robbes2012 mentions the large impact API changes can have on an ecosystem.
Bogart et al. @Bogart2016 studied the attitude of developers towards breaking changes in
dependencies. Their main findings were that an ecosystem plays an essential role in
the way we can deal with breaking changes. Both papers conclude that developers generally
do not respond in time to breaking changes and as a result breaking changes can have
a large impact on a software ecosystem. This conclusion is reinforced by the findings of
Decan et al. @Decan2018, where frequent changes can lead to an unstable dependency network
due to transitive dependencies.

Not only do developers not react in a timely fashion to breaking changes, Robbes et al.
@Robbes2012 also found that developers are also not quick to respond to API deprecation.
Bavota et al. @Bavota2014 suggests that updates should only be done when they consist of bug fixes,
not API changes, to combat this issue. 

Attempts have also been made to find a metric that establishes the 'health' of a 
dependency. Cox et al. @Cox2015 contributes to this by providing a metric
to establish the freshness of a dependency.

An interesting finding in the topic of package dependency networks by Kikas et al.
@Kikas2017 is that ecosystems, over time, become less dependent on a single popular package.

### RQ2: What are the practical implications of the state of the art?
<!-- Rather than theoretical, actual case studies done with findings -->
In this research question we aim to find out the practical implications of the state of the art as
discussed in the previous section. The papers discussed in this section are mostly case studies
and we will summarize their findings.

From most papers we find that developers are slow when updating their dependencies, or sometimes
they do not even do it at all. Hora et al. @Hora2016 suggest that a main reason for this is that
breaking changes cannot be solved in a uniform manner throughout the ecosystem, but rather need a
specific implementation for each system. We have also found that breaking changes are constantly
introduced when dependencies are updated. According to Raemaekers, van Deursen and Visser
@Raemaekers2017, about 33% of releases, either minor or major, contain a breaking change that
needs looking into. Breaking changes could pose compiling errors, thereby breaking the system that
depends on it.

Developers tend to react poorly to changes in their dependencies; Kula et al. @Kula2017 have found
that, of the 4600 surveyed projects, 81.5% of the projects contain outdated dependencies which
can lead to security risks. Not only do developers not update their dependencies, according to
an empirically study conducted by McDonnell, Ray and Kim @McDonnell2013 on the android API, they
also do not update their codebase with respect to the changes introduced by dependencies.

Regarding ecosystem health, Constantinou and Mens @Constantinou2017 have researched which factors
indicate that a developer is likely to abandon an ecosystem. Their study, which analysed
GitHub[^5.3] issues and commits, has found that developers are more likely to abandon a system when
they 1) do not communicate with their fellow developers, 2) do not participate often in social or
technical activities and 3) for an extended period of time do not react or commit any more. Another
interesting characteristic about ecosystem health, studied by Kula et al. @Kula2017-2, is the way
in which projects age over time. Their study found that the usage over time of 81.7% of 4,659
popular GitHub projects can be fitted on a function with an order higher than two.

Malloy and Power @Malloy2018 have studied the transition from Python 2 to Python 3. Python 3 has
been out since 2008, and the final Python 2 release was in 2010. Both are (almost) 10 years ago.
Even though, during their study they have found that most Python developers choose to maintain
compatibility with both Python 2 and Python 3 by only using a subset of the Python 3 language.
Malloy and Power @Malloy2018 state that they are severely limiting themselves in their language
capabilities, by not using the newly developed features.

Another interesting topic of research is the impact tools can have on ecosystems. Among these
tools are badges. Badges are annotations on software projects which display some information
about a software project. One of these badges can warn developers about outdated packages.
Based on the results of Trockman @Trockman2018, badges can have a positive impact on the speed at
which developers update their dependencies.

Overall we can conclude that there are a lot of improvements to be made. The current method that
most users use to manage their dependencies is lacking. Whether it be updating late or not
updating at all, there are many risks bound to this. Dietrich, Jezek, and Brada @Dietrich2014 have
also found that there are a lot of problems in the Java ecosystem, and has posed a set of
relatively minor changes to both development tools and the Java language itself that could be very
effective. These improvements are highlighted by answering the last research question.

### RQ3: What are the open challenges in ecosystem analytics, for which future research is required?
<!--List of challenges, research questions and an aggregated set of open research items -->
This research question gives insight in the current open challenges in the field of ecosystem
analytics. It focuses on the challenges described in the studied papers.

The most common open challenge across almost all papers is the generalization of results. Most of
the studied papers only use a single ecosystem on which they base their results. This in turn
means that it is unsure whether these results hold for other ecosystems as well in a similar
fashion. For example, Claes et al. @Claes2015 state that a possibility for future work is to
investigate to what extent the findings can be reused in the framework of other package-based
software distributions.

However, even if multiple ecosystems are researched within one paper, it shows to still not be
enough to provide a generalization for each ecosystem. Decan, Mens, and Grosjean @Decan2018 state,
after researching dependency network evolution for seven ecosystems, that they do not make any
claims that their results can be generalized beyond the main package managers for specific
languages. This is because Decan, Mens, and Grosjean @Decan2018 do not expect similar results for
networks such as WordPress, as these packages tend to be more high-level (e.g. used by end users
instead of reused by other packages). This is shown as well in the different results obtained by
Bogart et al. @Bogart2016, which shows that values differ per ecosystem. This overall shows that
there is a lot of space for future research to be done in generalizing research beyond the already
researched ecosystems.

Another persistent open challenge is the ability to determine the health of an ecosystem. Although
Jansen @Jansen2014 has provided OSEHO, "a framework that is used to establish the health of an
open source ecosystem", Jansen @Jansen2014 notes that "there is surprisingly little literature
available about open source ecosystem health". Kikas et al. @Kikas2017 agree, stating that a
general goal is to provide analytics to maintainers about the overall ecosystem trends.

This challenge is related to determining a systems health. Kikas et al. @Kikas2017 state that "a
measure quantifying dependency health in an ecosystem should be developed". Moreover, according to
Jansen @Jansen2014, determining the health of a system from an ecosystem perspective is required
to determine which systems to use.

Because of this, this challenge ties into the assistance while selecting packages as well. This
challenge is about selecting the best dependency, according to the functionality needs of the
existing application. Abdalkareem et al. @Abdalkareem2017 state that helping developers find the
best packages suiting their needs need to be addressed. Kikas et al. @Kikas2017 agree that another
general goal is to provide maintainers with tools to manage their dependencies.

However, whenever these dependencies are chosen, another open challenge is to assist maintainers
to keep these dependencies up to date. In order to find out when dependencies have to be updated,
metrics have to be defined. Bavota et al. @Bavota2014 state that their observations could be a
starting point to build recommenders for supporting developers in complex dependency upgrade
activity. Cox et al. @Cox2015 provide "a metric to aid stakeholders in deciding on whether the
dependencies of a system should be updated". However, Cox et al. @Cox2015 state multiple
refinements on this metric which could still be researched.

